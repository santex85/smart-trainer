"""Chat with AI coach: history, send message, optional orchestrator run, optional FIT upload."""

import asyncio
import hashlib
import json
from datetime import date, datetime, timedelta, timezone
from typing import Annotated

from fastapi import APIRouter, Body, Depends, File, Form, HTTPException, Query, UploadFile
from pydantic import BaseModel
from sqlalchemy import delete, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import get_current_user
from app.db.session import get_db
from app.models.athlete_profile import AthleteProfile
from app.models.chat_message import ChatMessage, MessageRole
from app.models.chat_thread import ChatThread
from app.models.food_log import FoodLog
from app.models.sleep_extraction import SleepExtraction
from app.models.user import User
from app.models.wellness_cache import WellnessCache
from app.models.workout import Workout
from app.schemas.pagination import PaginatedResponse
from app.services.fit_parser import parse_fit_session
from app.services.orchestrator import run_daily_decision

router = APIRouter(prefix="/chat", tags=["chat"])

CHAT_SYSTEM = """You are a sports coach. You have the following context about the athlete. Use it to give brief, practical advice.
- Reply in 3–6 short bullets. If a section has no data, say "No data" for that topic; never invent numbers.
- Only use numbers that appear in the context; if context is empty for a section, say you don't have that data."""


# Context limits: last N days, last M workouts, max chars per section to keep prompts smaller
CHAT_CONTEXT_DAYS = 7
CHAT_WORKOUTS_LIMIT = 10
CHAT_SECTION_MAX_CHARS = 1200


async def _build_athlete_context(session: AsyncSession, user_id: int, is_premium: bool = False) -> str:
    """Build a compressed text summary: profile, food/wellness today + last N days, last M workouts. No passwords/tokens."""
    today = date.today()
    sleep_from = today - timedelta(days=CHAT_CONTEXT_DAYS)
    wellness_from = today - timedelta(days=CHAT_CONTEXT_DAYS)
    from_dt = datetime.combine(wellness_from, datetime.min.time()).replace(tzinfo=timezone.utc)
    to_dt = datetime.combine(today + timedelta(days=1), datetime.min.time()).replace(tzinfo=timezone.utc)

    (
        r_user,
        r_prof,
        r_food,
        r_wellness,
        r_sleep_list,
        r_well,
        r_w,
    ) = await asyncio.gather(
        session.execute(select(User.email).where(User.id == user_id)),
        session.execute(select(AthleteProfile).where(AthleteProfile.user_id == user_id)),
        session.execute(
            select(FoodLog.name, FoodLog.portion_grams, FoodLog.calories, FoodLog.protein_g, FoodLog.fat_g, FoodLog.carbs_g, FoodLog.meal_type, FoodLog.timestamp, FoodLog.extended_nutrients).where(
                FoodLog.user_id == user_id,
                FoodLog.timestamp >= datetime.combine(today, datetime.min.time()),
                FoodLog.timestamp < datetime.combine(today + timedelta(days=1), datetime.min.time()),
            )
        ),
        session.execute(
            select(WellnessCache).where(
                WellnessCache.user_id == user_id,
                WellnessCache.date == today,
            )
        ),
        session.execute(
            select(SleepExtraction.created_at, SleepExtraction.extracted_data).where(
                SleepExtraction.user_id == user_id,
                SleepExtraction.created_at >= from_dt,
            ).order_by(SleepExtraction.created_at.desc()).limit(20)
        ),
        session.execute(
            select(WellnessCache.date, WellnessCache.sleep_hours, WellnessCache.rhr, WellnessCache.hrv, WellnessCache.ctl, WellnessCache.atl, WellnessCache.tsb, WellnessCache.weight_kg).where(
                WellnessCache.user_id == user_id,
                WellnessCache.date >= wellness_from,
                WellnessCache.date <= today,
            ).order_by(WellnessCache.date.asc())
        ),
        session.execute(
            select(Workout).where(
                Workout.user_id == user_id,
                Workout.start_date >= from_dt,
                Workout.start_date < to_dt,
            ).order_by(Workout.start_date.desc()).limit(CHAT_WORKOUTS_LIMIT)
        ),
    )

    user_row = r_user.one_or_none()
    email = user_row[0] if user_row else None
    profile = r_prof.scalar_one_or_none()
    athlete = {}
    if profile:
        if profile.weight_kg is not None:
            athlete["weight_kg"] = float(profile.weight_kg)
        if profile.height_cm is not None:
            athlete["height_cm"] = float(profile.height_cm)
        if profile.birth_year is not None:
            athlete["birth_year"] = profile.birth_year
            athlete["age_years"] = today.year - profile.birth_year
        if profile.ftp is not None:
            athlete["ftp"] = profile.ftp
    if not athlete.get("display_name") and email:
        athlete["display_name"] = email

    rows = r_food.all()
    food_sum = {"calories": 0.0, "protein_g": 0.0, "fat_g": 0.0, "carbs_g": 0.0}
    food_entries = []
    for row in rows:
        food_sum["calories"] += row[2] or 0
        food_sum["protein_g"] += row[3] or 0
        food_sum["fat_g"] += row[4] or 0
        food_sum["carbs_g"] += row[5] or 0
        food_entries.append({
            "name": row[0], "portion_grams": row[1], "calories": row[2], "protein_g": row[3], "fat_g": row[4], "carbs_g": row[5],
            "meal_type": row[6], "timestamp": row[7].isoformat() if row[7] else None,
            "extended_nutrients": row[8] if is_premium else None,
        })

    w = r_wellness.scalar_one_or_none()
    wellness_today = None
    ctl_atl_tsb = None
    if w:
        wellness_today = {"sleep_hours": w.sleep_hours, "rhr": w.rhr, "hrv": w.hrv, "weight_kg": w.weight_kg}
        ctl_atl_tsb = {"ctl": w.ctl, "atl": w.atl, "tsb": w.tsb}
    if wellness_today is None:
        wellness_today = {}

    sleep_entries = []
    for created_at, data_json in r_sleep_list.all():
        try:
            data = json.loads(data_json) if isinstance(data_json, str) else data_json
        except (json.JSONDecodeError, TypeError):
            continue
        created_date = created_at.date() if created_at and hasattr(created_at, "date") else None
        sleep_entries.append({
            "date": created_date.isoformat() if created_date else None,
            "recorded_at": created_at.isoformat() if created_at else None,
            "sleep_date": data.get("date"),
            "sleep_hours": data.get("sleep_hours"),
            "actual_sleep_hours": data.get("actual_sleep_hours"),
            "quality_score": data.get("quality_score"),
            "deep_sleep_min": data.get("deep_sleep_min"),
            "rem_min": data.get("rem_min"),
        })
    sleep_summary = json.dumps(sleep_entries, default=str) if sleep_entries else "No sleep data from photos."

    wellness_history = []
    for row in r_well.all():
        wellness_history.append({
            "date": row[0].isoformat() if row[0] else None,
            "sleep_hours": row[1], "rhr": row[2], "hrv": row[3], "ctl": row[4], "atl": row[5], "tsb": row[6], "weight_kg": row[7],
        })

    workouts = []
    for w in r_w.scalars().all():
        d = w.start_date.date() if w.start_date and hasattr(w.start_date, "date") else None
        workouts.append({
            "date": d.isoformat() if d else None,
            "name": w.name,
            "type": w.type,
            "duration_sec": w.duration_sec,
            "distance_km": round(w.distance_m / 1000, 1) if w.distance_m is not None else None,
            "tss": w.tss,
            "source": w.source,
        })

    def _cap(s: str, limit: int = CHAT_SECTION_MAX_CHARS) -> str:
        s = s.strip()
        return s if len(s) <= limit else s[: limit - 3] + "..."

    parts = [
        "## Athlete profile (weight, height, age, FTP, name, sex)",
        _cap(json.dumps(athlete, default=str)),
        "## Food today (sum)",
        f"Calories: {food_sum['calories']:.0f}, Protein: {food_sum['protein_g']:.0f}g, Fat: {food_sum['fat_g']:.0f}g, Carbs: {food_sum['carbs_g']:.0f}g",
        "## Food today (entries)",
        _cap(json.dumps(food_entries, default=str)),
        "## Wellness today (sleep, RHR, HRV)",
        _cap(json.dumps(wellness_today or {})),
        "## Load (CTL/ATL/TSB)",
        _cap(json.dumps(ctl_atl_tsb or {})),
        "## Wellness history (last %d days)" % CHAT_CONTEXT_DAYS,
        _cap(json.dumps(wellness_history, default=str)),
        "## Sleep (from photos, last %d days)" % CHAT_CONTEXT_DAYS,
        _cap(sleep_summary),
        "## Recent workouts (manual/FIT)",
        _cap(json.dumps(workouts, default=str)),
    ]
    return "\n".join(parts)


def _fit_data_to_summary(data: dict) -> str:
    """Build a short text summary of parsed FIT session for AI context."""
    parts = []
    start = data.get("start_date")
    if start:
        parts.append(f"Date/time: {start}")
    if data.get("duration_sec"):
        m = data["duration_sec"] // 60
        parts.append(f"Duration: {m} min")
    if data.get("distance_m"):
        parts.append(f"Distance: {data['distance_m'] / 1000:.1f} km")
    if data.get("sport"):
        parts.append(f"Sport: {data['sport']}")
    if data.get("avg_heart_rate") is not None:
        parts.append(f"Avg HR: {data['avg_heart_rate']} bpm")
    if data.get("max_heart_rate") is not None:
        parts.append(f"Max HR: {data['max_heart_rate']} bpm")
    if data.get("avg_power") is not None:
        parts.append(f"Avg power: {data['avg_power']} W")
    if data.get("normalized_power") is not None:
        parts.append(f"NP: {data['normalized_power']} W")
    if data.get("total_calories") is not None:
        parts.append(f"Calories: {data['total_calories']}")
    return "; ".join(parts) if parts else "No session data"


class SendMessageBody(BaseModel):
    message: str
    run_orchestrator: bool = False  # if True, run daily decision and include in context
    thread_id: int | None = None  # if None, use default (first) thread or create one


class CreateThreadBody(BaseModel):
    title: str | None = None


class RunOrchestratorBody(BaseModel):
    locale: str = "ru"
    for_date: date | None = None


async def _get_or_create_default_thread(session: AsyncSession, user_id: int) -> ChatThread:
    """Return first thread for user or create one 'Основной'."""
    r = await session.execute(
        select(ChatThread).where(ChatThread.user_id == user_id).order_by(ChatThread.id.asc()).limit(1)
    )
    thread = r.scalar_one_or_none()
    if thread:
        return thread
    thread = ChatThread(user_id=user_id, title="Основной")
    session.add(thread)
    await session.flush()
    return thread


@router.get(
    "/threads",
    response_model=PaginatedResponse,
    summary="List chat threads",
    responses={401: {"description": "Not authenticated"}},
)
async def list_threads(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    limit: int = Query(default=50, ge=1, le=200),
    offset: int = Query(default=0, ge=0),
) -> PaginatedResponse:
    """List chat threads for the current user, ordered by created_at desc (paginated)."""
    uid = user.id
    base = select(ChatThread).where(ChatThread.user_id == uid).order_by(ChatThread.created_at.desc())
    count_q = select(func.count()).select_from(base.subquery())
    total = (await session.execute(count_q)).scalar() or 0
    r = await session.execute(base.offset(offset).limit(limit))
    threads = r.scalars().all()
    items = [
        {"id": t.id, "title": t.title, "created_at": t.created_at.isoformat() if t.created_at else None}
        for t in threads
    ]
    return PaginatedResponse(
        items=items,
        total=total,
        limit=limit,
        offset=offset,
        has_more=(offset + limit) < total,
    )


@router.post(
    "/threads",
    response_model=dict,
    summary="Create chat thread",
    responses={401: {"description": "Not authenticated"}},
)
async def create_thread(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    body: CreateThreadBody | None = None,
) -> dict:
    """Create a new chat thread."""
    uid = user.id
    title = (body.title if body else "") or ""
    title = title.strip() or "Новый чат"
    thread = ChatThread(user_id=uid, title=title)
    session.add(thread)
    await session.commit()
    await session.refresh(thread)
    return {"id": thread.id, "title": thread.title, "created_at": thread.created_at.isoformat() if thread.created_at else None}


class UpdateThreadBody(BaseModel):
    title: str


@router.patch(
    "/threads/{thread_id}",
    response_model=dict,
    summary="Update chat thread (rename)",
    responses={401: {"description": "Not authenticated"}, 404: {"description": "Thread not found"}},
)
async def update_thread(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    thread_id: int,
    body: UpdateThreadBody,
) -> dict:
    """Rename a chat thread."""
    uid = user.id
    r = await session.execute(select(ChatThread).where(ChatThread.id == thread_id, ChatThread.user_id == uid))
    thread = r.scalar_one_or_none()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")
    title = (body.title or "").strip() or "Чат"
    thread.title = title[:128]
    await session.commit()
    await session.refresh(thread)
    return {"id": thread.id, "title": thread.title, "created_at": thread.created_at.isoformat() if thread.created_at else None}


@router.delete(
    "/threads/{thread_id}",
    summary="Delete chat thread",
    responses={401: {"description": "Not authenticated"}, 404: {"description": "Thread not found"}},
)
async def delete_thread(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    thread_id: int,
) -> None:
    """Delete a thread and all its messages (cascade)."""
    uid = user.id
    r = await session.execute(select(ChatThread).where(ChatThread.id == thread_id, ChatThread.user_id == uid))
    thread = r.scalar_one_or_none()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")
    await session.delete(thread)
    await session.commit()


@router.post(
    "/threads/{thread_id}/clear",
    summary="Clear thread messages",
    responses={401: {"description": "Not authenticated"}, 404: {"description": "Thread not found"}},
)
async def clear_thread(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    thread_id: int,
) -> dict:
    """Delete all messages in the thread; thread remains."""
    uid = user.id
    r = await session.execute(select(ChatThread).where(ChatThread.id == thread_id, ChatThread.user_id == uid))
    thread = r.scalar_one_or_none()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")
    await session.execute(delete(ChatMessage).where(ChatMessage.thread_id == thread_id))
    await session.commit()
    return {"ok": True}


@router.get(
    "/history",
    summary="Get chat history",
    responses={401: {"description": "Not authenticated"}},
)
async def get_history(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    thread_id: int | None = None,
    limit: int = 50,
) -> list[dict]:
    """Return recent chat messages for a thread. If thread_id omitted, use default thread."""
    uid = user.id
    if thread_id is None:
        thread = await _get_or_create_default_thread(session, uid)
        thread_id = thread.id
    else:
        r = await session.execute(select(ChatThread).where(ChatThread.id == thread_id, ChatThread.user_id == uid))
        if r.scalar_one_or_none() is None:
            raise HTTPException(status_code=404, detail="Thread not found")
    r = await session.execute(
        select(ChatMessage)
        .where(ChatMessage.user_id == uid, ChatMessage.thread_id == thread_id)
        .order_by(ChatMessage.timestamp.desc())
        .limit(limit)
    )
    rows = r.scalars().all()
    return [
        {"role": m.role, "content": m.content, "timestamp": m.timestamp.isoformat() if m.timestamp else None}
        for m in reversed(rows)
    ]


@router.post(
    "/send",
    response_model=dict,
    summary="Send chat message",
    responses={401: {"description": "Not authenticated"}, 502: {"description": "AI service unavailable"}},
)
async def send_message(
    session: Annotated[AsyncSession, Depends(get_db)],
    body: SendMessageBody,
    user: Annotated[User, Depends(get_current_user)],
) -> dict:
    """Append user message, optionally run orchestrator, then get AI reply and return it."""
    uid = user.id
    thread_id = body.thread_id
    if thread_id is None:
        thread = await _get_or_create_default_thread(session, uid)
        thread_id = thread.id
    else:
        r = await session.execute(select(ChatThread).where(ChatThread.id == thread_id, ChatThread.user_id == uid))
        if r.scalar_one_or_none() is None:
            raise HTTPException(status_code=404, detail="Thread not found")

    session.add(
        ChatMessage(user_id=uid, thread_id=thread_id, role=MessageRole.user.value, content=body.message)
    )
    await session.flush()

    reply = ""
    if body.run_orchestrator:
        result = await run_daily_decision(session, uid, date.today())
        reply = f"Decision: {result.decision.value}. {result.reason}"
        if result.suggestions_next_days:
            reply += f"\n\n{result.suggestions_next_days}"
    else:
        import google.generativeai as genai
        from app.config import settings
        from app.services.gemini_common import run_generate_content
        context = await _build_athlete_context(session, uid, user.is_premium)
        model = genai.GenerativeModel(settings.gemini_model)
        prompt = f"{CHAT_SYSTEM}\n\nContext:\n{context}\n\nUser message: {body.message}"
        response = await run_generate_content(model, prompt)
        reply = response.text if response and response.text else "No response."

    session.add(
        ChatMessage(user_id=uid, thread_id=thread_id, role=MessageRole.assistant.value, content=reply)
    )
    await session.commit()
    return {"reply": reply}


@router.post(
    "/send-with-file",
    response_model=dict,
    summary="Send message with FIT file",
    responses={401: {"description": "Not authenticated"}, 502: {"description": "AI service unavailable"}},
)
async def send_message_with_file(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    message: Annotated[str, Form()] = "",
    run_orchestrator: Annotated[str, Form()] = "false",
    thread_id: Annotated[str | None, Form()] = None,
    save_workout: Annotated[str, Form()] = "false",
    file: Annotated[UploadFile | None, File()] = None,
) -> dict:
    """Send a message with optional FIT file. Uses multipart/form-data. When file is .fit, adds workout summary to context and optionally saves to diary."""
    uid = user.id
    run_orch = run_orchestrator.strip().lower() in ("true", "1")
    tid = int(thread_id) if (thread_id and str(thread_id).strip()) else None
    save_w = save_workout.strip().lower() in ("true", "1")

    if tid is None:
        thread = await _get_or_create_default_thread(session, uid)
        tid = thread.id
    else:
        r = await session.execute(select(ChatThread).where(ChatThread.id == tid, ChatThread.user_id == uid))
        if r.scalar_one_or_none() is None:
            raise HTTPException(status_code=404, detail="Thread not found")

    fit_summary: str | None = None
    fit_data: dict | None = None
    user_content = (message or "").strip()

    if file and file.filename and file.filename.lower().endswith(".fit"):
        content = await file.read()
        if not content:
            raise HTTPException(status_code=400, detail="Empty FIT file.")
        fit_data = parse_fit_session(content)
        if not fit_data:
            raise HTTPException(status_code=400, detail="Could not parse FIT file or no session found.")
        fit_summary = _fit_data_to_summary(fit_data)
        if not user_content:
            user_content = f"Приложен FIT-файл тренировки. {fit_summary[:300]}"

        if save_w and fit_data:
            checksum = hashlib.sha256(content).hexdigest()
            r = await session.execute(select(Workout).where(Workout.user_id == uid, Workout.fit_checksum == checksum))
            if r.scalar_one_or_none() is None:
                from app.api.v1.workouts import _estimate_tss_from_fit

                start_date = fit_data["start_date"]
                if isinstance(start_date, datetime) and start_date.tzinfo is None:
                    start_date = start_date.replace(tzinfo=timezone.utc)
                r2 = await session.execute(select(AthleteProfile).where(AthleteProfile.user_id == uid))
                profile = r2.scalar_one_or_none()
                ftp = None
                if profile and profile.ftp is not None:
                    ftp = float(profile.ftp)
                duration_sec = fit_data.get("duration_sec") or 0
                tss = _estimate_tss_from_fit(
                    duration_sec,
                    fit_data.get("avg_power"),
                    fit_data.get("normalized_power"),
                    ftp,
                    fit_data.get("sport"),
                )
                sport_name = (fit_data.get("sport") or "Workout").capitalize()
                w = Workout(
                    user_id=uid,
                    start_date=start_date,
                    name=sport_name,
                    type=sport_name,
                    duration_sec=duration_sec or None,
                    distance_m=fit_data.get("distance_m"),
                    tss=tss if tss > 0 else None,
                    source="fit",
                    fit_checksum=checksum,
                    raw=fit_data.get("raw"),
                )
                session.add(w)

    session.add(
        ChatMessage(user_id=uid, thread_id=tid, role=MessageRole.user.value, content=user_content or "(сообщение)")
    )
    await session.flush()

    reply = ""
    if run_orch:
        result = await run_daily_decision(session, uid, date.today())
        reply = f"Decision: {result.decision.value}. {result.reason}"
        if result.suggestions_next_days:
            reply += f"\n\n{result.suggestions_next_days}"
    else:
        import google.generativeai as genai
        from app.config import settings
        from app.services.gemini_common import run_generate_content

        context = await _build_athlete_context(session, uid, user.is_premium)
        if fit_summary:
            context += "\n\n## Uploaded workout (this message)\n" + fit_summary
        model = genai.GenerativeModel(settings.gemini_model)
        prompt = f"{CHAT_SYSTEM}\n\nContext:\n{context}\n\nUser message: {user_content or 'Разбери приложенную тренировку.'}"
        response = await run_generate_content(model, prompt)
        reply = response.text if response and response.text else "No response."

    session.add(
        ChatMessage(user_id=uid, thread_id=tid, role=MessageRole.assistant.value, content=reply)
    )
    await session.commit()
    return {"reply": reply}


@router.post(
    "/orchestrator/run",
    response_model=dict,
    summary="Run daily orchestrator",
    responses={401: {"description": "Not authenticated"}, 502: {"description": "Orchestrator failed"}},
)
async def run_orchestrator(
    session: Annotated[AsyncSession, Depends(get_db)],
    user: Annotated[User, Depends(get_current_user)],
    body: RunOrchestratorBody | None = Body(default=None),
) -> dict:
    """Run daily decision (Go/Modify/Skip) for today and return result. May update Intervals and add chat message."""
    uid = user.id
    locale = body.locale if body else "ru"
    for_date = body.for_date if body else None
    result = await run_daily_decision(session, uid, for_date or date.today(), locale=locale)
    await session.commit()
    return {
        "decision": result.decision.value,
        "reason": result.reason,
        "modified_plan": result.modified_plan.model_dump() if result.modified_plan else None,
        "suggestions_next_days": result.suggestions_next_days,
    }


