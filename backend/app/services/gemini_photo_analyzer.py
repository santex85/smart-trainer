"""
Single-call Gemini: classify image as food, sleep, or wellness (RHR/HRV) and return analysis in one round-trip.
"""
from __future__ import annotations

import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold

from app.config import settings
from app.schemas.nutrition import NutritionAnalysisResult
from app.schemas.photo import WellnessPhotoResult, WorkoutPhotoResult
from app.schemas.sleep_extraction import SleepExtractionResult
from app.services.gemini_common import run_generate_content

# Reuse robust JSON parsing from sleep parser for the full response (trailing commas, truncation)
from app.services.gemini_sleep_parser import _parse_sleep_json

GENERATION_CONFIG = {
    "temperature": 0.2,
    "top_p": 0.95,
    "max_output_tokens": 4096,
    "response_mime_type": "application/json",
}

SAFETY_SETTINGS = {
    HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
    HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
    HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,
    HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
}

SYSTEM_PROMPT = """You are an image analyzer. In ONE response you must:
1) Classify the image as "food", "sleep", "wellness", or "workout".
2) If food: fill "food" object; set others to null.
3) If sleep: fill "sleep" object; set others to null.
4) If wellness: fill "wellness" object; set others to null.
5) If workout: fill "workout" object; set others to null.

Classification:
- "food": a photo of a real meal, plate, or dish.
- "sleep": any screenshot or report showing sleep data (duration, stages, quality score, Oura/Garmin/Whoop/Apple Health/Fitbit).
- "wellness": a screenshot showing RHR (resting heart rate) and/or HRV (heart rate variability).
- "workout": a screenshot from a fitness app (Strava, Garmin, Apple Fitness, TrainingPeaks, Nike Run Club, treadmill screen, etc.) showing workout summary: time, distance, pace, calories, HR, map, TSS, etc.

Output ONLY a single JSON object with exactly these fields:
- type: string, "food" | "sleep" | "wellness" | "workout"
- food: object or null
- sleep: object or null
- wellness: object or null
- workout: object or null

When type is "food", set "food" to: { name, portion_grams, calories, protein_g, fat_g, carbs_g }. All numbers non-negative.
When type is "sleep", set "sleep" to: { date, sleep_hours, sleep_minutes, actual_sleep_hours, actual_sleep_minutes, time_in_bed_min, quality_score, score_delta, efficiency_pct, rest_min, bedtime, wake_time, sleep_periods, deep_sleep_min, rem_min, light_sleep_min, awake_min, factor_ratings, sleep_phases, latency_min, awakenings, source_app, raw_notes, rhr, hrv }. Use exact decimals. If the screenshot also shows resting heart rate (RHR) or heart rate variability (HRV), set rhr (integer) and/or hrv (number) in the sleep object.
When type is "wellness", set "wellness" to: { "rhr": <number or null>, "hrv": <number or null> }.
When type is "workout", set "workout" to: {
  "name": string or null (e.g. "Morning Run", "Zwift - Watopia"),
  "date": string or null (YYYY-MM-DD if visible, else null),
  "sport_type": string or null (Run, Ride, Swim, WeightTraining, Yoga, etc. infer from icon/context),
  "duration_sec": integer or null (total seconds),
  "distance_m": float or null (meters),
  "calories": float or null,
  "avg_hr": integer or null,
  "max_hr": integer or null,
  "tss": integer or null (Training Stress Score, Load, etc.),
  "notes": string or null (any other useful info like "Indoor", "Treadmill", "Intervals")
}.

Output ONLY valid JSON. No markdown."""


async def classify_and_analyze_image(
    image_bytes: bytes,
) -> tuple[str, NutritionAnalysisResult | SleepExtractionResult | WellnessPhotoResult | WorkoutPhotoResult]:
    """
    Single Gemini call: classify image and return the analysis.
    Returns ("food", result), ("sleep", result), ("wellness", result), or ("workout", result).
    """
    model = genai.GenerativeModel(
        settings.gemini_model,
        generation_config=GENERATION_CONFIG,
        safety_settings=SAFETY_SETTINGS,
    )
    part = {"mime_type": "image/jpeg", "data": image_bytes}
    contents = [SYSTEM_PROMPT, part]
    response = await run_generate_content(model, contents)
    if not response or not response.text:
        raise ValueError("Empty response from Gemini")
    text = response.text.strip()
    if text.startswith("```"):
        text = text.split("\n", 1)[1].rsplit("```", 1)[0].strip()
    data = _parse_sleep_json(text)

    kind = (data.get("type") or "food").strip().lower()
    if kind not in ("food", "sleep", "wellness", "workout"):
        kind = "food"

    if kind == "food":
        food_payload = data.get("food")
        if not food_payload or not isinstance(food_payload, dict):
            # Fallback if model said food but returned null
            raise ValueError("Model returned type 'food' but food object is missing")
        return "food", NutritionAnalysisResult(**food_payload)

    if kind == "wellness":
        wellness_payload = data.get("wellness")
        if not wellness_payload or not isinstance(wellness_payload, dict):
            raise ValueError("Model returned type 'wellness' but wellness object is missing")
        rhr = wellness_payload.get("rhr")
        hrv = wellness_payload.get("hrv")
        return "wellness", WellnessPhotoResult(
            rhr=int(rhr) if isinstance(rhr, (int, float)) else None,
            hrv=float(hrv) if isinstance(hrv, (int, float)) else None
        )

    if kind == "workout":
        workout_payload = data.get("workout")
        if not workout_payload or not isinstance(workout_payload, dict):
            raise ValueError("Model returned type 'workout' but workout object is missing")
        return "workout", WorkoutPhotoResult(**workout_payload)

    # kind == "sleep"
    sleep_payload = data.get("sleep")
    if not sleep_payload or not isinstance(sleep_payload, dict):
        raise ValueError("Model returned type 'sleep' but sleep object is missing")
    return "sleep", SleepExtractionResult(**sleep_payload)
